栈：一种数据结构，遵循LIFO的操作顺序，一般采用数组实现

在计算机系统中，栈也叫栈内存，是一个由系统自动分配的、连续的、动态的、最大大小固定的内存区域，用于存储函数内部局部变量、方法调用和函数参数值；因为 栈内存是由高地址向低地址延伸 的，所以栈在内存中顺序是 高地址是栈底（Base），低地址是栈顶（Top）

栈用于维护函数调用的上下文，离开了栈函数调用就没法实现。



CPU执行指令的过程就是不断的取指、译码、执行，CPU内部有一个叫做程序计数器的寄存器，用来保存CPU正在执行指令的下一条指令的地址

函数调用前后，有三件事情是必须做的：

1. 保存调用者执行的代码位置
2. 把程序计数器修改为被调用者的代码位置
3. 在被调用者执行完成后，把调用者的代码地址写入PC。

这三个功能是由两条指令来实现的，在x86-64的汇编指令集当中有一条指令call，这条指令可以实现1、2两个功能。

假如有函数A调用函数B，在执行前B函数之前，会执行call B指令。这条指令首先把地址A压入栈中，然后将PC设置为函数B的起始地址。压入栈的地址A称为返回地址，是函数A中紧跟在call B指令的下一条指令。

B函数的代码执行完之后，在最末尾会调用指令ret，这条指令会从栈中弹出地址A，并把PC设置为A，这样就可以愉快的接着执行A函数了。整个函数调用的控制转移只需要使用call和ret两条指令即可完成

call指令执行了2步操作

1. 将当前的 IP 或 CS和IP 压入栈中
2. 跳转，类似与jmp指令

ret指令也分2步

1. 将栈中的地址弹出到 IP 寄存器
2. 跳转执行后续指令



每一次函数的调用，都会在调用栈(call stack)上 维护一个独立的栈帧(stack frame)，它是一个连续的内存区块，是一个数据集。

当前正在运行的函数的栈帧总是在栈顶。每个独立的栈帧一般包括:

- 局部变量：为函数局部变量开辟的内存空间以及编译器自动生成的其他临时变量

- 栈帧状态值：保存前栈帧的顶部和底部(实际上只保存前栈帧的底部，前栈帧的顶部可以通过栈帧平衡计算得到)，用于在本栈被弹出后恢复出上一个栈帧

- 函数返回地址：保存当前函数调用前的“断点”信息，也就是函数调用前的指令位置，以便在函数返回时能够恢复到函数被调用前的代码区中继续执行指令

  注：函数栈帧的大小并不固定，一般与其对应函数的局部变量多少有关。函数运行过程中，其栈帧大小也是在不停变化的

##### 和函数调用相关的几个重要的寄存器

- EIP：指令寄存器(extended instruction pointer)，其内存放着一个指针，该指针永远 指向下一条等待执行的指令地址(代码内的偏移量)，每次执行完指令之后IP会增加

- ESP/RSP：栈指针寄存器(extended stack pointer)，其内存放着一个指针，该指针永远指向系统栈 最上面一个栈帧的栈顶(低地址)，SP

  压栈时，栈顶指针会指向新地址，所以 E/RSP中的地址数据是不断变化 的

- EBP(32位)/RBP(64位)：栈帧基址指针寄存器(extended base pointer)，其内存放着一个指针，该指针永远指向系统栈 最上面一个栈帧的底部(高地址)，每个栈帧都有一个对应的栈帧基地址，局部变量和函数参数都可以通过FP确定，因为它们到FP的距离不会受到压栈和出栈操作影响，FP

- 栈帧的边界由EBP/RBP和ESP/RSP界定(指针存放在相应寄存器中)

在函数调用的过程中，有函数的调用者(caller)和被调用的函数(callee)。调用者需要知道被调用者函数返回值；被调用者需要知道传入的参数和返回的地址;

##### **x86-64下16个通用寄存器**

![img](https://km.sankuai.com/api/file/cdn/310386088/310750638?contentType=1&isNewContent=false&isNewContent=false)

每个寄存器的用途并不是单一的。

%**rax** 通常用于存储**函数调用的返回结果**，同时也用于乘法和除法指令中

在imul 指令中，两个64位的乘法最多会产生128位的结果，需要 %rax 与 %rdx 共同存储乘法结果，在div 指令中被除数是128 位的，同样需要%rax 与 %rdx 共同存储被除数。

%**rsp** 是堆栈指针寄存器，通常会指向栈顶位置，堆栈的 pop 和push 操作就是通过改变 %rsp 的值即移动堆栈指针的位置来实现的。

%**rbp** 是栈帧指针，用于标识当前栈帧的起始位置

**%rdi,  %rsi,  %rdx,  %rcx, %r8,  %r9** 六个寄存器用于存储函数调用时的6个参数（如果有6个或6个以上参数的话）。

被标识为 “miscellaneous registers” 的寄存器，属于通用性更为广泛的寄存器，编译器或汇编程序可以根据需要存储任何数据。

> 这里还要区分一下 “Caller Save” 和 ”Callee Save” 寄存器，即寄存器的值是由”调用者保存“ 还是由 ”被调用者保存“。当产生函数调用时，子函数内通常也会使用到通用寄存器，那么这些寄存器中之前保存的调用者(父函数）的值就会被覆盖。为了避免数据覆盖而导致从子函数返回时寄存器中的数据不可恢复，CPU 体系结构中就规定了通用寄存器的保存方式。
>
> 如果一个寄存器被标识为”Caller Save”， 那么在进行子函数调用前，就需要由调用者提前保存好这些寄存器的值，保存方法通常是把寄存器的值压入堆栈中，调用者保存完成后，在被调用者（子函数）中就可以随意覆盖这些寄存器的值了。
>
> 如果一个寄存被标识为“Callee Save”，那么在函数调用时，调用者就不必保存这些寄存器的值而直接进行子函数调用，进入子函数后，子函数在覆盖这些寄存器之前，需要先保存这些寄存器的值，即这些寄存器的值是由被调用者来保存和恢复的 

CPU更新换代时，新的寄存器是兼容老的寄存器的，兼容图如下ax为16位寄存器，eax为32位寄存器，rax为64位寄存器

![img](https://km.sankuai.com/api/file/cdn/310386088/310973471?contentType=1&isNewContent=false&isNewContent=false)

#### 函数调用

函数调用分为以下几步:

- 参数入栈：主调函数把被调函数需要的参数值（实参）从右至左入栈
- 返回地址入栈：主调函数使用call指令正式调用被调函数，并把返回地址（即call指令的下一条指令的地址）入栈。返回地址入栈这一步是隐含的
- 代码跳转：处理器从当前代码区跳转到被调用函数的入口处
- 被调函数将主调函数的栈底地址(%ebp)入栈，并将该地址作为被调函数的栈顶地址(%esp)；
- 将被调函数中定义的 局部变量 按照定义的自然顺序（从左至右）入栈；
- 被调函数执行完毕后，将(%esp)上移，找到之前主调函数的栈底地址，并将它出栈。最后使用ret指令返回主调函数

代码块

CSS

```
函数调用的开始基本上都是以下汇编,这两句用于构建函数的栈帧头
pushq %rbp
movq  %rsp, %rbp

然后函数的返回汇编一般是
retq
```

每个栈帧都会存储上一栈帧的EBP内存储的基地址，并且它是作为分界线：

向被调函数传入的参数位于该EBP的栈底方向（较高地址），而被调函数自己的局部变量位于该EBP的栈顶方向（较低地址），进退自如

在函数栈中主要包括 **函数参数表、局部变量表、栈的基址和函数返回地址**。**这里栈的基址是上一个栈帧的基址**，因为在本函数中需要使用该基址访问栈中的内容，因此需要首先将上一个栈帧中的基址压栈

![img](https://km.sankuai.com/api/file/cdn/310386088/310926783?contentType=1&isNewContent=false&isNewContent=false)

#### 函数返回

函数返回分为以下几步:

- 保存被调用函数的返回值，通常将函数的返回值保存在寄存器EAX中；mov eax, xxx
- 弹出当前帧，恢复上一个栈帧。具体包括：
  - 在堆栈平衡的基础上，给ESP加上栈帧的大小，降低栈顶，回收当前栈帧的空间；mov ebp, esp
  - 将当前栈帧底部保存的前栈帧EBP值弹入EBP寄存器，恢复出上一个栈帧。pop ebp
  - 将函数返回地址弹给ESP寄存器。

- 跳转：按照函数返回地址跳回母函数中继续执行

#### 参考资料

[系统栈的工作原理](https://www.cnblogs.com/dwlsxj/p/Stack.html)

《程序员的自我修养》有空得好好读读了，好多知识都是那上面的

《Unix环境高级编程》

[深入理解函数调用（上）](https://zhuanlan.zhihu.com/p/24577273?refer=hinus)

[深入理解函数调用（下）](https://zhuanlan.zhihu.com/p/24596628?refer=hinus)

[iOS-查看线程调用栈](https://www.jianshu.com/p/f4359eb9529a)

❤️[iOS堆栈信息解析（函数地址与符号关联）](https://www.jianshu.com/p/df5b08330afd)

❤️[程序员必备高级技术之函数调用栈](https://juejin.im/post/5d1d465051882579df4a4745)