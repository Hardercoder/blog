[TOC]



## 其他知识

在 Objc 中，Block 是一个特殊的对象，它的实例并非是常规的对象结构，而是以 `Block_layout` 结构体的形式存在。在声明时，Block 的结构体会以值类型的形式直接存储在栈上，随后会被 copy 到堆上，成为一个特殊的对象


 Block 和常规对象都是通过 isa 指向的类对象记录基本信息，区别在于 Block 对象后面跟的是捕获的变量列表，而常规对象后面跟的是 ivar 实例列表

## 基本概念

### 在ARM架构中，寄存器间传送数据的指令依然是MOV，比如*"MOV Ra Rb"* 就是把Rb里存放的数据传送给Ra，但内存单元上的数据不允许被直接操作，而是必须先放到寄存器中，为此就有了把内存的内容传送到寄存器的指令LDR(Load)，以及把寄存器的内容传送回内存的指令STR(Store)

### "**[]**"在这里就对应C语言里的"*"，表示取地址里的内容

### 多个寄存器在ARM汇编语言中用"**{}**"圈起来，表示待传送的寄存器列表。





**汇编的所有指令操作都是围绕栈实现的，在汇编中，没有变量的概念，只有寄存器和内存**

在编译器生成汇编时，首先会计算需要的栈空间大小，并利用sp指针向低地址开辟相应的空间

**ARM64汇编为了提高访问效率要求按照16字节进行对齐**

在函数中可以直接插入汇编代码来影响函数的运行逻辑，使用的语法为编译指令`__asm__`，注意插入汇编有可能会被编译器忽略，因此需要加入`__volatile__`修饰符保证汇编代码有效（需要xcode连接真机运行）

Segment 是 Section 的集合，Segment 会指引着系统在指定的位置加载 Section，Segment 为下划线开头的大写字母组合，Section 为下划线开头的小写字母组合，Segment 会由编译系统自动创建

在汇编中，数据和代码是存储在一起的，数据本质上也是一种代码

### 编译成汇编 xcrun --sdk iphoneos clang -S -arch arm64 helloworld.c

### 编译器指令：以'.'开头,用于告知编译器相关的信息或者进行特定操作

### 标签(label:) 用于辅助定位代码或者资源地址, 也便于开发者理解和记忆

### 汇编指令,会被汇编器编译为机器代码, 最终被cpu所执行

### @PAGE表示获取标签所在的页的地址（按0x1000或0x4000对齐）

### @PAGEOFF表示获取标签地址相对于页地址的偏移，在经过汇编器汇编后会将标签汇编为字符串所存放的地址，让程序可以定位到字符串

### 方法头(prologue), 用于保存上一个方法调用栈帧的帧头及预留部分栈空间用于局部变量

### 方法尾(epilogue)， 用于取出方法头中栈帧信息及方法的返回地址, 并将栈恢复到方法调用前的位置

### **局部变量是放在栈上的！**

### **由于ARM64没有指令可以直接把常数放入内存，所以编译器采用了把常数先放入寄存器，再从寄存器中存入内存的方式来实现**

### d系列寄存器是'b,h,s,d,q'也就是'byte, half, single, double, quad'共用的，q寄存器有128位，d用它的低64位，s用它的低32位，h用它的低16位，b用它的低8位

### **变量本质是一块用来存放数据的存储空间，而变量名称则是对这块空间所处位置的用于助记的别名。在汇编中没有变量名称的概念（千万不要搞混变量和符号），只有用来存储数据的寄存器和内存**

### **subsections_via_symbols**的意思是可以将汇编中整块代码根据符号拆分成不同的区块。这些区块可以根据是否被其他代码引用而被剔除

### 声明是用于告知编译器某个变量的存在以及其类型的, 变量在被实际赋值之前也是**会**占用空间的

### **ARM64下对于使用SP作为地址基址寻址的时候，必须要16byte-alignment（对齐）**

###  对局部变量的赋值直接上是把运算的结果(一般存放在寄存器中), 保存到栈上分配给变量空间里.

### ARM64 Calling Convention规定了整数型返回值放在x0寄存器里

### **对栈的分配/释放操作只会对栈指针做加减法, 而不会对栈内存中的内容做任何修改**

### 在C中语句是用`;`作为分隔符的表达式, 而括号'{'和'}'将语句包裹成一个复合语句或者块.'

#### {'和'}'可以被当做C语言用来组织代码或者规划作用域的语法糖

#### `if (a) {}`也是C语言给`if (a != 0) {}`的语法糖!

### `switch`的实现和`if else`实现的差别在于, `switch`是一次判断跟着两个跳转, 条件满足跳分支1不满足跳分支2; 而`if else`是一次判断跟着一次跳转, 条件满足调分支1不满足则继续执行下一次判断

### 寄存器**X0**在函数调用时用于存放第一个整数参数, 寄存器**X1**用于存放第二个整数参数, 寄存器**X0**中存储函数的返回值

**X0-X7**中顺序存第1~8个参数, 后面的参数存在**[sp]**和**[sp, #4]**对应的地址处，也就是栈上!

#### **外部变量包含变量和函数, 对于汇编层面来讲, 外部的变量和函数其实都是一个可被找到的符号(更确切的来说应该是地址)**

#### 全局变量**a**是放在了**__DATA,__data**节里。在我们使用该全局变量的时候，我们从对应a数据所属的地址上获取**a**的值，获取其值的方式，是将**a**的地址加载到寄存器中，然后通过**ldr**指令提取对应地址上的值

### 对于汇编来说, 其实并不太有作用域的概念, 所有的数据都存在栈/符号/寄存器中, 在汇编层面对于数据的操作具有绝对的访问/控制能力

### 采用了**extern**的方式声明变量**a**,在汇编上采用了通过GOT的方式来查找a。这里**GOT**的含义是**Global Offset Table**。在链接的过程中, 会将其他源代码中的a符号放入**GOT**表, 让a符号可以被全局访问到。

### 头文件的主要意义在于让编译器可以找到特定方法/变量/数据结构（统称为符号）的申明，使得在只有库没有没有源代码情况下，确认某些符号是否存在，如果头文件中没有具体的实现/定义, 将对汇编代码的生成没有影响

### 静态变量(static)分为两种情况, 全局静态变量和内部静态变量.

#### 全局静态变量是指放在方法体外的变量前加上static修饰, 它使得全局变量对外（编译单元）不可见

全局静态变量在汇编层面缺少了.**global**的符号声明，也就意味着**a**符号对编译单元外不可见。

#### 内部静态变量是指写在方法体内静态变量, 它的赋值语句只会被执行一次，

符号名叫**main.a**，意味着它是**main**函数中一个局部静态变量**a**

其实它也没有赋值的过程(**static int a = 1没有赋值!**), 而是在编译期就将初始值通过**.long 1**放入了数据段,

### 寄存器变量

是指强制要求变量被一直存放在寄存器中, 而不是像通常的局部变量一样放入栈中, 这样可以提高对此变量的访问性能. 注意, 关键字**register**可能会直接被编译器忽略! 

### 块结构

#### **块结构实际上将作用域做了进一步的细分, 而前面提到其实汇编没有变量作用域的概念, C语言不同块之间的变量在汇编中都存放在栈上的不同位置, 互不影响.**

### 初始化

局部变量的初始化, 通常是将整数放入寄存器然后放入栈中, 将浮点数从数据段放入寄存器然后放入栈中.

全局变量和静态变量的初始化, 通常是将数据放入预先编译到数据段, 使用时从数据段移动到寄存器然后进行运算.

### 在汇编层面, 所有的数据都存在栈/符号/寄存器中, 栈和符号都属于内存范畴, 进一步抽象就是, 所有的数据都在内存和寄存器中(这里先不讨论协处理器或者外部存储等其他范畴). 而指针的本质就是内存的地址!

指针用汇编的说法来解释, 就是一个地址指向的内存里面存的内容是另一个地址!

如果我们传递的参数是一个整数, 那么寄存器/栈中存的就是整数, 那如果我们传的参数是一个指针, 那么寄存器/栈中存的就是地址!

### **结构体在运行时的本质是一片按照结构体定义分配的内存**

构的成员变量按照偏移从依此从低地址分布到高地址，加上ARM64的地址空间符合递减的特征，即栈顶所在内存地址高于栈底地址

### **ARM64下，结构体大小默认按8 byte对齐**

















### 栈

**汇编中的栈是由高地址向低地址生长的数据结构，sp指针永远指向栈顶，需要记住的是，在某位置进行存储时，是向高地址进行的**

## 常用寄存器

## 常用指令

### str和ldr是一对指令

str的全称是**store register，即将寄存器的值存储到内存中**，

ldr的全称是**load register，即将内存中的值读到寄存器**

他们的第一个参数都是寄存器，第二个参数都是内存地址

## 工具和调用约定

[Call Convention](https://www.theiphonewiki.com/wiki/Kernel_Syscalls)

https://github.com/facebook/fishhook

## 参考资料

### iOS调试进阶

https://zhuanlan.zhihu.com/c_142064221

https://zhuanlan.zhihu.com/p/31168062

https://zhuanlan.zhihu.com/p/31168191

https://zhuanlan.zhihu.com/p/31345589

https://zhuanlan.zhihu.com/p/31393274

https://zhuanlan.zhihu.com/p/31633326

https://zhuanlan.zhihu.com/p/32071435

https://zhuanlan.zhihu.com/p/32310843

https://zhuanlan.zhihu.com/p/32925502

### iOS汇编入门教程

https://juejin.cn/post/6844903576855117831

https://juejin.cn/post/6844903582139940877

https://juejin.cn/post/6844903809819344909

https://juejin.cn/post/6844903927624761352

https://juejin.cn/post/6844903950391443464

https://juejin.cn/post/6844903957614034957

https://juejin.cn/post/6844903970536685576

https://juejin.cn/post/6844903981488013319

### Segment和Section的区别

https://stackoverflow.com/questions/14361248/whats-the-difference-of-section-and-segment-in-elf-file-format

http://jmpews.github.io/2017/08/09/darwin/%E5%8F%8D%E8%B0%83%E8%AF%95%E5%8F%8A%E7%BB%95%E8%BF%87/

https://developer.arm.com/documentation/dui0802/a/

### ARM汇编语言

https://zhuanlan.zhihu.com/p/82490125



