[TOC]

### 面向过程(POP)与面向对象(OOP)

- “面向过程”是一种以过程为中心的编程思想。就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。注重的是实现过程!

- “面向对象”是一种以对象为中心的编程思想，有三大特性
  - **封装：**隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性
  - **继承：**提高代码复用性，建立了类之间的关系，子类可以拥有父类的所有成员变量的方法，继承是多态的前提
  - **多态：**父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，提高了程序的拓展性

### 编译型和解释型的区别

- 编译型语言：首先是将源代码编译生成机器指令，再由机器运行机器码 (二进制)
- 解释型语言：源代码不是直接翻译成机器指令，而是先翻译成中间代码，再由解释器对中间代码进行解释运行

### 动态语言和静态语言

- 动态类型语言：是指数据类型的检查是在运行时做的，在运行时可以改变类结构，比如添加移除方法和属性等
- 静态类型语言：是指数据类型的检查是在运行前（如编译阶段）做的

### 简要说明const,宏,static,extern区分以及使用

- **const**

  ```c++
  const常量修饰符,经常使用的字符串常量，一般是抽成宏，但是苹果不推荐我们抽成宏，推荐我们使用const常量。
  - const 作用：限制类型
  - 使用const修饰基本变量, 两种写法效果一致 , b都是只读变量
    const int b = 5; 
    int const b = 5;   
  - 使用const修饰指针变量的变量 
  	const int *p = &a 和 int const *q = &a; 效果一致,*p 的值不能改,p 的指向可以改; 
  	int * const p = &a;  表示 p 的指向不能改,*p 的值可以改
    const int * const p = &a; *p 值和 p 的指向都不能改
    
    const 在*左边, 指向可变, 值不可变
    const 在*的右边, 指向不可变, 值可变
    const 在*的两边, 都不可变
  /*
  合理地使用关键字const可以使编译器保护那些不希望被改变的参数，防止其被无意的代码修改，减少bug。
  
  欲阻止一个变量被改变，可以使用 const 关键字。在定义该 const 变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；
  对指针来说，可以指定指针本身为 const，也可以指定指针所指的数据为 const，或二者同时指定为 const；
  在一个函数声明中，const 可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；
  对于类的成员函数，若指定其为 const 类型，则表明其是一个常函数，不能修改类的成员变量；
  对于类的成员函数，有时候必须指定其返回值为 const 类型，以使得其返回值不为“左值”。
  */
  ```

- **宏**

  ```c++
  * 基本概念：宏是一种批量处理的称谓。一般说来，宏是一种规则或模式，或称语法替换 ，用于说明某一特定输入（通常是字符串）如何根据预定义的规则转换成对应的输出（通常也是字符串)。这种替换在预编译时进行，称作宏展开。编译器会在编译前扫描代码，如果遇到我们已经定义好的宏那么就会进行代码替换，宏只会在内存中copy一份，然后全局替换，宏一般分为对象宏和函数宏。 宏的弊端：如果代码中大量的使用宏会使预编译时间变长。
  
  const与宏的区别？
  * 时机：宏在预处理阶段进行替换，const常量在编译阶段使用
  * 编译检查：宏没有编译检查，仅仅进行纯替换；const有数据类型，会进行编译检查；
  * 宏不能调试，const可以用于调试
  * 宏的好处 定义函数、方法；const不可以；
  * 宏的坏处 大量使用宏，会导致预编译时间过长
  ```

- **static**

  ```css
  函数（方法）体内 static 变量的作用范围为该函数体，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；
  在模块内的 static 全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问；
  在模块内的 static 函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明 它的模块内；
  在类中的 static 成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；
  在类中的 static 成员函数属于整个类所拥有，这个函数不接收 this 指针，因而只能访问类的static 成员变量
  
  static 用途
  限制变量的作用域
  设置变量的存储域
  ```

- **extern**

  ```objective-c
  声明外部全局变量(只能用于声明，不能用于定义)
  
  常用用法（.h结合extern联合使用）
  如果在.h文件中声明了extern全局变量，那么在同一个类中的.m文件对全局变量的赋值必须是：数据类型+变量名（与声明一致）=XXXX结构。并且在调用的时候，必须导入.h文件。代码如下：
  
  .h
  @interface ExternModel : NSObject
  extern NSString *lhString;
  @end 
  .m     
  @implementation ExternModel
  NSString *lhString=@"hello";
  @end
  
  调用的时候：例如：在viewController.m中调用，则可以引入：ExternModel.h，否则无法识别全局变量。当然也可以通过不导入头文件的方式进行调用（通过extern调用）。
  ```

### 指针常量、常量指针和指向常量的常量指针

- 常量指针本质是指针，常量修饰它，表示这个指针是一个指向常量的指针（变量）。
  指针指向的对象是常量，这个对象不能被更改。

- 指针常量的本质是一个常量，而用指针修饰它，那么说明这个常量的值应该是一个指针。
  指针常量的值是指针，这个值因为是常量，所以不能被赋值

  ```css
  int *const p:指针常量，其本质是一个常量（用指针修饰），这个常量的内容是一个指针，不可以修改p指向的地址，但是可以修改*p的值。定义的时候要赋初值。（数组名也是一个指针常量）
  
  int const *p(const int *p):常量指针，其本质是一个指针（用const修饰）。说明它指向的对象是一个常量，这个对象不能被更改，可以修改p指向的地址，但是不可以修改*p的值。
  
  const int *const p:指向常量的常量指针，既不可以修改p指向的地址，也不可以修改*p的值。
  /*
  指针和 const 谁在前先读谁
  *象征着地址，const象征着内容
  谁在前面谁就不允许改变
  */
  ```

### 说出以下指针的含义

```css
int **a : 指向一个指针的指针，该指针指向一个整数。
int *a[10] : 指向一个有10个指针的数组，每个指针指向一个整数。
int (*a)[10] : 指向一个有10个整数数组的指针。
int (*a)(int) : 指向一个函数的指针，该函数有一个整数参数，并返回一个整数。
```

### 指针函数和函数指针

- 指针函数： 顾名思义，它的本质是一个函数，不过它的返回值是一个指针

  ```c
  // 指针函数
  int *sum(int a, int b){
      int result = a + b;
      int *c = &result;
      return c;
  }
  int *p = sum(10, 20);
  printf("sum:%d\n", *p);
  ```

- 与指针函数不同，函数指针的本质是一个指针，该指针的地址指向了一个函数，所以它是指向函数的指针。

  ```c
  // 函数指针
  int max(int a, int b){
      return (a > b)?a:b;
  }
  int (*p)(int, int) = max;
  int result = p(10, 20);
  printf("result:%d\n", result);
  ```

### 关键字volatile有什么含意?并给出不同的例子

- 一个定义为`volatile`的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是`volatile`变量的几个例子
  - 并行设备的硬件寄存器（如：状态寄存器）
  - 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)；
  - 多线程应用中被几个任务共享的变量
  
- 一个参数既可以是 const 还可以是 volatile 吗？解释为什么。

  - 是的。一个例子是只读的状态寄存器。它是 volatile 因为它可能被意想不到地改变。它是 const 因为程序不应该试图去修改它

- 一个指针可以是 volatile 吗？解释为什么。
     - 是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个buffer的指针时

### strcpy和memcpy的最大区别是什么?

- 复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，字符数组、整型、结构体、类等
- 复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符"\0"才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度
- 用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy

### SVN 和 Git 区别

- svn 和 git 都是用来对项目进行版本控制以及代码管理的，可以监测代码及资源的更改变化，有利于实现高效的团队合作
- svn 是集中式的，集中式是指只有一个远程版本库。git 是分布式的，分布式有本地和远程版本库，本地仓库都保留了整个项目的完整备份
- 如果存储远程版本库的服务器挂了，所有人的代码都无法提交，甚至丢失版本库，git则因为有本地版本库而不会有这个问题
- 由于两者的架构不同，git 和 svn 的分支也是不同的。svn 的分支是一个完整的目录，包含所有的实际文件，和中心仓库是保持同步的，如果某个团队成员创建新的分支，那么会同步到所有的版本成员中，所有人都会收到影响。而 git下创建的分支合并前是不会影响到任何人的，创建分支可以在本地脱机进行任何操作，测试无误后在合并到主分支，然后其他成员才可以看得到